#!/usr/bin/perl
use strict;
use warnings;

# Copyright (C) 2017  Christian Garbs <mitch@cgarbs.de>
# Licensed under GNU GPL v2 or later.

use feature qw(say);

use IO::File;

my @stack_stack;
my $current_stack;
my $ops;

sub init_stack
{
    $current_stack = [];
}

sub init_stacks
{
    @stack_stack   = ();
    init_stack;
}

sub stack_length
{
    return @{$current_stack};
}

sub stack_empty
{
    return stack_length == 0;
}

sub push_stack
{
    push @{$current_stack}, shift;
}

sub pop_stack
{
    die "stack exhausted\n" if stack_empty;
    return pop @{$current_stack};
}

sub push_stack_stack
{
    push @stack_stack, $current_stack;
}

sub pop_stack_stack
{
    die "stack_stack exhausted\n" unless @stack_stack;
    $current_stack = pop @stack_stack;
}

sub clone
{
    return [ @{ shift() } ];
}

sub inner_op2
{
    my ($op, $arg1, $arg2) = @_;

    if (ref $arg1 eq 'ARRAY') {
	$arg1 = clone $arg1;
	foreach my $elem (@{$arg1}) {
	    $elem = inner_op2( $op, $elem, $arg2 );
	}
	return $arg1;
    }
    elsif (ref $arg2 eq 'ARRAY') {
	$arg2 = clone $arg2;
	foreach my $elem (@{$arg2}) {
	    $elem = inner_op2( $op, $arg1, $elem );
	}
	return $arg2;
    }
    else {
	return $op->( $arg1, $arg2 );
    }
}

sub do_op2
{
    my $op = shift;
    my ($arg1, $arg2) = (pop_stack(), pop_stack());

    my $result = inner_op2 $op, $arg1, $arg2;

    push_stack $result ;
}

sub do_repeat
{
    my $repeat_op = shift;

    process_token( $repeat_op ) while stack_length > 1;
}

$ops = {
    '+'  => sub { do_op2( sub { $_[0] + $_[1] } ) }, # addition
    '-'  => sub { do_op2( sub { $_[0] - $_[1] } ) }, # subtraction
    '*'  => sub { do_op2( sub { $_[0] * $_[1] } ) }, # multiplication
    '/'  => sub { do_op2( sub { $_[0] / $_[1] } ) }, # division

    '!+' => sub { do_repeat('+') },    # repeated addition
    '!-' => sub { do_repeat('-') },    # repeated subtraction
    '!*' => sub { do_repeat('*') },    # repeated multiplication
    '!/' => sub { do_repeat('/') },    # repeated division

    '('  => sub {                      # start substack
	push_stack_stack;
	init_stack;
    },
    ')'  => sub {                      # end substack, return top element
	my $ret = pop_stack;
	pop_stack_stack;
	push_stack $ret;
    },

    '['  => sub {                      # start list
	push_stack_stack;
	init_stack;
    },
    ']'  => sub {                      # end list, push list to stack
	my $list = $current_stack;
	pop_stack_stack;
	push_stack $list;
    },

    'seq' => sub {                     # generate sequence
	my $max = pop_stack;
	push_stack $_ for 1 .. $max;
    },
};

sub process_token
{
    my $token = shift;

    if (exists $ops->{$token}) {
	$ops->{$token}->();
    }
    else {
	push_stack $token;
    }
}

sub for_print
{
    my $token = shift;

    if (ref $token eq 'ARRAY') {
	return join ' ', ('[', map { for_print($_) }  @{$token}, ']');
    }
    else
    {
	return $token;
    }
}

sub execute
{
    my $tokens = shift;

    init_stacks;
    process_token $_ foreach split /\s+/, $tokens;
    return for_print pop_stack;
}

sub repl
{
    my $fh = shift;
    
    say execute $_ while ( defined( $_ = $fh->getline) );
}

# only start repl if started as a script
repl( bless(\*STDIN => 'IO::File') ) unless defined caller() and caller ne 'PAR';
